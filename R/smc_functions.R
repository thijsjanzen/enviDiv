#' draw parameter combinations from the prior
#' @param empty_input empty vector, used to facilitate usage of apply
#' @return vector with 7 entries: extinction, sympatric speciation at high water, sympatric speciation at low water, allopatric speciation, amount of jiggle and the chosen water model
#' @export
param_from_prior <- function(empty_input) {
  output <- c()
  output[1] <- 10 ^ (-3 + 5 * stats::runif(1, 0, 1))  #extinction
  output[2] <- 10 ^ (-3 + 5 * stats::runif(1, 0, 1))  #symp spec high
  output[3] <- 10 ^ (-3 + 5 * stats::runif(1, 0, 1))  #symp spec low
  output[4] <- 10 ^ (-3 + 5 * stats::runif(1, 0, 1))  #allo spec
  output[5] <- 10 ^ (-3 + 3 * stats::runif(1, 0, 1))  #jiggle
  output[6] <- sample(1:3, 1) # model
  output[7] <- 1

  return(output)
}

#' perturbate all parameters
#' @param params input vector containing unperturbed parameters
#' @param local_sd standard deviation of the perturbation kernel
#' @return perturbed parameters
#' @export
mutate_param <- function(params, local_sd) {
  output <- c()
  for(i in 1:5) {
    output[i] <- 10^(stats::rnorm(1, log10(params[i]), local_sd))
  }

  output[6] <- params[6]
  r = sample(1:4, 1)
  if(r == 0) output[6] <- params[6] + 1
  if(r == 1) output[6] <- params[6] - 1
  if(output[6] > 2) output[6] <- output[6] - 3
  if(output[6] < 1) output[6] <- output[6] + 3

  output[7] <- params[7]
  return(output)
}

#' calculate summary statistics for a focal tree. The following summary statistics are calculated: nLTT, gamma, mean branching times and number of lineages
#' @param focal_tree input phylogenetic tree for which to calculate summary statistics.
#' @param emp_tree reference empirical tree, necessary to calculate the nLTT.
#' @return vector of four summary statistics
#' @export
calc_sum_stats <- function(focal_tree, emp_tree) {
  # trees that are extinct turn up as NULL:
  if(is.null(focal_tree)) {
    return(rep(Inf, 4))
  }

  # trees with only 2 tips turn up with an empty edgelist (they are only a crown)
  if(is.null(focal_tree$edge.length)) {
    return(rep(Inf, 4))
  }

  focal_tree <- ape::multi2di(focal_tree)

  if(min(ape::branching.times(focal_tree), na.rm=T) < 0) {
    cat("ERROR, negative branch lengths!\n")
    return(rep(Inf, 4))
  }
  if(focal_tree$Nnode + 1 < 3) {
    return(rep(Inf, 4))
  }

  output <- c()
  output[1] <- nLTT::nltt_diff_exact(focal_tree, emp_tree)
  output[2] <- ape::gammaStat(focal_tree) # gamma
  output[3] <- mean(focal_tree$edge.length, na.rm=T) # mean branch length
  output[4] <- focal_tree$Nnode + 1 # number of lineages

  return(output)
}

#' function to determine if the parameter combination is within the prior
#' @param params vector of parameters
#' @return true or false
#' @export
within_prior <- function(params) {
  for(i in 1:4) {
    if(log10(params[i]) < -3) return(FALSE)
    if(log10(params[i]) >  2) return(FALSE)
  }
  if(log10(params[5]) < -3) return(FALSE)
  if(log10(params[5]) >  0) return(FALSE)

  if(params[6] < 1) return(FALSE)
  if(params[6] > 3) return(FALSE)

  return(TRUE)
}

#' function to calculate the weight of a particle. The weight depends on the probability of obtaining the specific parameter combination, given all the previous parameters. Hence, it is the sum of the probability for each previous parameter combination to obtain the observed parameter combination.
#' @param params focal parameters for which to estimate the weight
#' @param other_params previous params from which this parameter combination is derived
#' @param weights previous weights
#' @param sigma standard deviation of the perturbation kernel
#' @return weight
#' @export
calculate_weight <- function(params,
                             other_params,
                             weights,
                             sigma) {
  diff <- log10(params[1:5]) - log10(other_params[,1:5]) #only the numerical ones
  vals <- weights * stats::dnorm(diff, mean = 0, sd = sigma)

  model_prob <- params[6] - other_params[,6]
  model_prob[which(model_prob != 0)] <- 0.25
  model_prob[which(model_prob == 0)] <- 0.5
  vals <- model_prob * vals

  # do something with model weights
  return(1.0 / sum(vals) )
}

#' calculate the overall fit of the particle to the data
#' @param sum_stats summary statistics of the tree generated by the particle
#' @param emp_stats summary statistics of the empirical tree
#' @return sum of normalized differences between the summary statistics
#' @export
calc_fit <- function(sum_stats,
                     emp_stats) {

  diff <- sum_stats  - emp_stats
  diff <- diff * diff
  diff <- diff / c(0.25, 2, 0.8, 75)
  return(sum(diff))
}
